# TS Library tips: Rollup your types!

> ğŸ’ this article uses following library versions:

```json
{
  "@types/react": "16.x.x",
  "@types/react-dom": "16.x.x",
  "typescript": "3.x.x",
  "react": "16.5.2",
  "react-dom": "16.5.2"
}
```

> ğŸ® [source code can be found on my github profile](https://github.com/Hotell/blogposts/tree/master/{date}/{title})

---

> This article is part of series about Shipping a TypeScript Library tips

> ## TL;DR
>
> When authoring a TypeScript library make sure to follow best industry practices like shipping smallest possible files by rollup-ing your javascript code. As a not very known technique apply this pattern also on your ambient types definitions, that are generated by TypeScript compiler - bundling them into 1 single `.d.ts` file, which will also mitigate misuse of your possible leaking private APIs.

If you're writing a JavaScript library or application, you'll definitely need some kind of bundler. There are various options on the market, most familiar are probably webpack and rollup. Webpack is mostly used for apps and rollup for libraries although although both can be used for the opposite thing. Because we're talking about shipping libraries lets focus on Rollup.

> NOTE: this article will not go through how to configure Rollup or how it works in detail

Rollup helps us bundle our library into 1 file!

Which in practice means following transformation:

```
// Raw source:
src
â”œâ”€â”€ components
â”‚   â”œâ”€â”€ counter.tsx
â”‚   â””â”€â”€ greeter.tsx
â”œâ”€â”€ index.ts
â”œâ”€â”€ math.ts
â””â”€â”€ types.ts
â†“â†“â†“

// Bundled via Rollup:

dist/
â”œâ”€â”€ index.js
```

This is fantastic as we're shipping our library to consumers with following advantages:

- less kB transferred via wire
- faster install time
- faster bundling time in apps (webpack/rollup has to process only 1 files instead of N)
- faster tests (cold starts can be painfully slow especially if you're using jest and your app is massive)
- better tree-shaking

Now what about types ? You've might noticed that our contrived library is written in TypeScript. So what kind of types are we talking about ?

### Bundling declaration files

To to leverage TypeScript to full extent you definitely wanna ship type declarations to your consumers, so no matter if they use TS or NOT, their editor/CI can give them excellent DX thanks to your library typings.

To emit those type declaration, you'll need to enable following config in your `tsconfig.json`

```jsonc
{
  "declaration": true,
  "declarationDir": "dist/dts",
  // optional if you're using babel to transpile TS - JS
  "emitDeclarationOnly": true
}
```

With our tsconfig set, if we execute `rollup` (which is also properly configured via plugins), or if we just run raw `tsc`, we'll get following file tree:

```
dist/
â”œâ”€â”€ index.js
â”œâ”€ dts
    â”œâ”€â”€ components
    â”‚   â”œâ”€â”€ counter.d.ts
    â”‚   â”œâ”€â”€ counter.d.ts.map
    â”‚   â”œâ”€â”€ greeter.d.ts
    â”‚   â””â”€â”€ greeter.d.ts.map
    â”œâ”€â”€ index.d.ts
    â”œâ”€â”€ index.d.ts.map
    â”œâ”€â”€ math.d.ts
    â”œâ”€â”€ math.d.ts.map
    â”œâ”€â”€ types.d.ts
    â””â”€â”€ types.d.ts.map
```

What happened? Our whole library tree structure is mirrored by emitted `.d.ts` files.

While we have optimized runtime by rolluping js files into 1, we have quite messy `.d.ts` output that might inflict potential issues:

- consumers can use/access parts of our codebase, that might not be intended as public API surface (which will not work if we rollup-ed our runtime ofc)
- bigger baggage over wire
- potentially slower TypeScript type-check time (if you don't use `skipLibCheck:true`)

How can we fix those ? Rollup time.

## There are various existing OSS projects that will help us what we need.

-
-

We'll focus on 2 particular ones - api-extractor and dts-.....

### API Extractor

#### Pros

#### Const

### DTS-.....

#### Pros

#### Const

## Conclusion

In this article we learned how to apply best practices in terms of bundling TS library on both runtime and type declarations. In the end we showcased how this can be done by leveraging existing OSS libraries with brief feature comparison.

Hopefully you'll be able to apply this pattern sooner than later and make ~the world~ (I meant world of type definitions) a better place.

Until next time.

Cheers!

---

As always, don't hesitate to ping me if you have any questions here or on Twitter (my handle [@martin_hotell](https://twitter.com/martin_hotell)) and besides that, happy type checking folks and 'till next time! Cheers! ğŸ–– ğŸŒŠ ğŸ„

```

```
